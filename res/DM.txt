(** Quelques invocations préliminaires *)

(** Pour l'arithmetique : vous pouvez utiliser "lia." (nouvelle
version de "omega.") pour résoudre automatiquement les buts
d'arithmétique linéaire. *)
Require Import Nat Arith Omega Psatz.
Import Nat.

(** Pour les listes : mêmes notations qu'en OCaml, [] et _ :: _ *)
Require Import List.
Import ListNotations.

(**
  Ce TP/DM doit être réalisé individuellement et déposé sauf cas de 
  force majeure sur moodle avant le dimanche 5 avril. Nous vous conseillons
  de le commencer pendant les créneaux de TP de la semaine du 23 mars après 
  avoir terminé le TP 1. Nous serons là pour répondre à vos questions.

  La correction sera manuelle mais le fichier doit être accepté 
  intégralement par Coq. L'ordre des questions doit être respecté. Il est possible
  d'utiliser une fonction/un lemme demandé dans une question précédente.

  Le module type POW_NAT contient des définitions imposées et les signatures des 
  opérations que vous devrez définir dans l'implantation, ainsi que les énoncés des
  lemmes et théorèmes que vous devrez démontrer.

  L'implantation pow_nat de POW_NAT contient les définitions imposées et un code par 
  défaut marqué TODO pour les opérations que vous devrez définir. Il faudra le remplacer
  par votre définition. La liste d'arguments et le type de retour ne devront pas être modifiés
  pour que la compatibilité avec POW_NAT soit assurée.

  Le code contient aussi les énoncés des lemmes ou théorèmes à démontrer.
  Il faudra donner les tactiques de construction de la preuve et remplacer
  Admitted par Qed si vous arrivez au bout de la preuve.

  Des fonctions ou lemmes auxiliaires peuvent être ajoutés 
  (avec un commentaire explicatif) mais c'est a priori inutile.
*)


Module Type POW_NAT.

  Definition N := nat. (** representation imposée *)
  Definition E := list bool. (** Exposant - représentation imposée *)

  Definition incrN : N -> N := S. (** successeur *)
  Parameter incrE : E -> E.

  Parameter pow_fast : N -> E -> N.
  Definition pow : N -> N -> N := Nat.pow. (** puissance *)

  Parameter encode : N -> E.
  Parameter decode : E -> N.

  Axiom dec_enc: forall n, decode (encode n) = n.
  Axiom incr_encode: forall n, incrE (encode n) = encode (incrN n).
  Axiom decode_incr: forall e, decode (incrE e) = incrN (decode e).
  Axiom pow_eq: forall e n, pow_fast n e = pow n (decode e).
End POW_NAT.

Print Nat.pow.

(** Cette partie a pour but de montrer la correction de la fonction
d'«exponentiation rapide». Pour éviter de manipuler les divisions
entières (bien que l'opération existe en Coq), on passe par une
représentation binaire des entiers sous la forme d'une liste de
booléens. On sera ainsi amené a raisonner tantôt sur des entiers,
tantôt sur des listes. *)

Module pow_nat <: POW_NAT.
  
  Definition N := nat. (** representation imposée *)
  Definition E := list bool. (** Exposant - représentation imposée *)

  Definition incrN : N -> N := S. (** successeur - imposé *)
  Definition pow := Nat.pow. (** puissance - imposé, aussi notée ^ *)
  
  (** Définir la fonction decode prenant en argument une liste de
      booléens contenant la représentation binaire d'un entier, poids
      faibles en tête, et renvoyant un entier. Par exemple :

[ decode [false; false; true; false; true] = 20 ] (** 10100 en base 2 *)

On évitera d'utiliser l'opérateur "*".
 *)
Fixpoint decode (l : list bool) : nat := 
  match l with
  | [] => 0
  | x :: reste => (if x then 1 else 0) + 2 * (decode reste)
  end.
  
  Eval compute in decode [false; false; true; false; true].
  (** Définir la fonction incrE prenant en argument une liste de booléens
      représentant le codage binaire d'un entier, poids faibles en tête, et
      renvoyant le codage binaire de son successeur. Par exemple:

[ incrE [true;true] = [false;false;true] ] (* 3+1=4 *)
   *)
Fixpoint incrE (l : list bool) : list bool := 
    match l with
    | [] => [true]
    | x :: reste => (negb x) :: (if x then (incrE reste) else reste)
    end.
    
  Eval compute in incrE [true; false; true; false; true].

  (* Définir la fonction encode prenant en argument un entier et
      renvoyant sa représentation binaire sous forme d'une liste de
      booléens. Par exemple:

[ encode 3 = [true;true] ]
 *)
  Fixpoint encode (n : nat) : list bool := 
  match n : nat with
  | 0 => [false]
  | x => incrE (encode (x-1))
  end.
  
  Eval compute in encode (5).
  

  (* lemme auxiliaire *)
  Lemma encode_m2 : forall n, n <> 0 -> encode (n + n) = false :: encode n.
  Proof.
  intros.
  simpl.
  destruct n.
  - auto.
  - simpl. auto. rewrite (plus_n_Sm).
  (* Indication: on procédera par induction sur n et on utilisera le
      lemme [plus_n_Sm] de la librairie Coq. 
      Pour exploiter l'hypothèse d'induction, il sera nécessaire de considérer
      2 cas, selon que n est nul ou non. On fera [destruct n].
   *)
  Admitted.

  Lemma decode_incr (l : list bool): decode (incrE l) = incrN (decode l).
  Proof.
    (** Indication: on procèdera par induction sur l. *)
  Admitted.


  Lemma incr_encode n: incrE (encode n) = encode (S n).
  Proof.
    (** La preuve est directe (non inductive) *)
  Admitted.


  (** On démontre maintenant la correction des fonctions d'encodage et de décodage 
   *)
  Theorem dec_enc : forall n, decode (encode n) = n.
  Proof.
    (** Indication: On procèdera par induction sur n et on utilisera [decode_incr] *)
  Admitted.

  (** Définir la fonction pow_fast prenant en argument un entier b et
      une liste de booléens représentant le codage binaire d'un entier e et
      renvoyant l'entier b^e. Par exemple:

[pow_fast 3 [false;false;true] = 81]

On utilisera les propriétés suivantes:

- [b^0 = 1]
- [b^{2e} = (b*b)^e]
- [b^{2e+1} = b * (b*b)^e]
 *)
  Fixpoint pow_fast (b : nat) (e : list bool) : nat := (* TODO *)0.

  Lemma pow_eq: forall e n, pow_fast n e = n ^ (decode e).
  Proof.
  (** On procèdera par induction sur e et on utilisera le fait que
      [b*b=b^2], la propriété [pow_mul_r] ainsi que la tactique [f_equal] pour
      transformer un but [f e1=f e2] en [e1=e2]. *)
  Admitted.

End pow_nat.